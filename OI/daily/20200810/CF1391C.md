#### 思路及一些证明

~~十分毒瘤的一道题目 , 10号打vp和tommy两个人弄了1个多钟头才弄出来。~~

通过对于顺序数据及小数据的枚举不难发现 , 如果是一个单峰或者单调的排列 , 那么就没有环 , 否则一定有。  

下面来证明(以下 , 单峰包括单调) : (证明过于毒瘤不想看的可以跳过)

$\texttt{Axiom1}$  

非单峰序列一定能被划分为若干个单峰序列。

$\texttt{Lemma1}$

在 $n$ 个节点的无向连通图中要存在环 , 至少要包含 $n$ 条边。  

$\texttt{Prof.}$ 

连通图中 , 若仅含 $n - 1$ 条边则是树 , 再加入更多的边形成环。  

$\texttt{Lemma2}$  

由题中方式生成的排列必为连通图。  

$\texttt{Theorem1}$  

生成的图含有环当且仅当排列为非单峰(包括单调 , 即这个峰在排列的一端)。  

$\texttt{Prof.}$ 先证必要性 , 再证充分性。  

必要性证明 :   $\texttt{i.e}.$ 对于形成环的图必为非单峰排列。  

$\texttt{Proof:}$ 反证法。  

以反证为目的假设存在单峰排列能形成有环的图。

对于单峰的排列 , 显然在峰的左侧每个下标为 $i$ 结点只向  $i+1$ 连一条边 , 因为右边的点的值都小于它。在峰的右侧每个下标为 $i$ 结点只向  $i-1$ 连一条边。峰不主动向其它点连边。这样总共只有 $n - 1$ 条边。由 $\texttt{Lemma1}$ 及 $\texttt{Lemma2}$ , 这样生成的图必然是一棵树。$\texttt{Contradiction!}$

则假设不成立 , 原命题成立。  $\texttt{Q.E.D.}$

充分性证明 $\texttt{i.e.}$ 非单峰排列生成的图中必定存在环。

$\texttt{Proof:} $ 对于长度为 $n$ 的排列。由 $\texttt{Axiom1}$ 将非单峰排列划分为若干个单峰子断。在每个单峰子段由 $\texttt{Lemma1}$ 和 $\texttt{Lemma2}$ 为一棵树 , 而谷中的元素将树连接成一棵更大的树。这样就有 $n - 1$ 条边。对于多个峰 , 峰之间显然存在大小关系。以最小的峰为例 , 它将与相邻的更大的峰有一个连边。这样至少有了 $\geqslant n$ 条边。由 $\texttt{Lemma1}$ , 这样的图中必然存在环。$\texttt{Q.E.D.}$

$\texttt{Q.E.D.}$



那么本题就是求非单峰排列的数量。正难则反 , 我们考虑求出单峰排列的数量 , 用全排列数 $n!$ 减去之。  

对于大小为 $n$ 的排列 , 假设峰在第 $k$ 个位置 , 即$p_k = n$。将剩下的元素分配到 $1...k-1$ 和 $k+1, ..., r$ 两个部分。分配完成后由于定序只有一种排列方案。分配的方式就是将 $1,...,n-1$ 分配到两个集合中 , 即 $\binom{n}{k-1}$ 种方法。  

记 $f(n)$ 为大小为 $n$ 的单峰排列个数 , 则 : 
$$
f(n) = \sum_{k \in [1,n]} \binom{n-1}{k-1} = 2^{n - 1}
$$
故答案即为 $n! - 2^{n-1}$ 

#### code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const ll p = 1000000007;

ll gen(int n) {
	ll ans = 1, dd = 1;
	for(int i = 1; i <= n; ++i) ans = ans * i % p;
	for(int i = 1; i < n; ++i) dd = dd * 2 % p;
	return ((ans - dd) % p + p) % p;
}

int main() {
	int n;
	cin >> n;
	cout << gen(n) << endl;
	return 0;
}
```